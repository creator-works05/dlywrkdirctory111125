The role of async and await
    The async keyword is absolutely crucial here; it fundamentally enables the use of the await keyword within the function block. It formally designates the function as operating in an asynchronous context.
The Role of async
Enables await: An await keyword is syntactically invalid outside of an async function. The async function implicitly wraps the entire functionâ€™s return value in a Promise, which is necessary for the JavaScript runtime to manage the pausing and resuming of execution.
Asynchronous Abbreviation: Yes, async is an abbreviation for asynchronous. It tells the JavaScript engine, "This function contains operations that will pause execution temporarily without blocking the main thread, and its ultimate result will be a Promise."
Why You Can't Just Use a Normal Function (Callback Stacking)
You are experiencing cognitive strain because moving the await logic into a standard, synchronous function fundamentally breaks the non-blocking nature of JavaScript's concurrency model.
Synchronous vs. Asynchronous Execution
Normal Function (Synchronous Stack)
If you tried to stack your operations in a normal function without async/await, the code would execute synchronously.
You would call placeGift().
The function would immediately return a pending Promise object, not the resolved value you need.
The synchronous function would immediately proceed to call wrapGift() with the pending Promise as an argument, which would fail.
The function would execute all calls instantly and finish before any of the actual Promise operations had time to complete.
async Function (The Importance of the "Guy")
The async function works by ceding control to the JavaScript event loop when it hits an await expression.
When the runtime hits await placeGift(), it pauses the execution of that specific async function (the rest of your application keeps running).
It waits for the placeGift Promise to resolve.
Once resolved, the event loop puts the rest of your async function's code back in the queue to run.
The function then proceeds to the next line (await wrapGift()) and repeats the process.
The async keyword acts as the necessary orchestrator, ensuring that these operations are performed sequentially but asynchronously, without blocking the browser's main thread.

----------------------------------------------------------------------------------------------------------------------------------

How "The Rest of Your Application Keeps Running"
Yes, the behavior of await is similar in principle to setTimeout() in that neither "blocks" the entire JavaScript environment, but the underlying mechanisms and priorities differ slightly. When an async function hits an await expression, it doesn't freeze the browser tab or Node.js process. 
Non-Blocking Behavior: JavaScript is fundamentally single-threaded. This means it processes one command at a time on the main thread. To prevent long-running tasks (like fetching data, reading files, or waiting for a timer) from making the entire application unresponsive, these tasks are offloaded to Web APIs (provided by the browser environment) to run in the background.
Ceding Control: When await placeGift() runs, the placeGift operation begins in the background. The await keyword tells the JavaScript Event Loop: "I'm done with this part of my function for now; you can go execute all the other pending synchronous code, handle user clicks, animations, or process other queued tasks."
Analogy: It's like a chef taking a cake (the asynchronous task) and putting it in the oven (the Web API). The chef (the main thread) doesn't just stand there staring at the oven. The chef immediately moves on to chopping vegetables or making sauce (the rest of your application's code) and only comes back to the cake when the oven timer goes off (the promise resolves). 
The "Pending Promise" Return Value
When a function that returns a Promise (like placeGift()) is called without await in a normal, synchronous function, it immediately hands back a Promise object to the caller. 
What it is: A Promise is essentially a placeholder object representing the eventual result of an operation that hasn't finished yet.
The State: This object starts in a pending state. It doesn't contain the actual final data (e.g., the "Gift placed successfully" string); it holds an internal pointer to a future value that will be filled in later.
Why you can't use the value: Without using await or .then(), you can't directly access the final, resolved value because it simply doesn't exist yet. The object you get back is just the mechanism for tracking that future result, not the result itself. You must "unwrap" the promise with await (inside an async function) or a .then() callback to get the actual data. 
Would you like to explore how to convert your existing setTimeout functions into Promises so they can be properly used with the await keyword?

